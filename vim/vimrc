" Modified: Sun 27 Jul 2014 10:48 am

set nocompatible

" Pathogen Setup {{{ ----------------------------------------------------------

"filetype off " Pathogen needs to run before plugin indent on
"call pathogen#infect()
"call pathogen#helptags() " generate helptags for everything in 'runtimepath'
"filetype plugin indent on

" }}}
" Vundle Setup {{{ ------------------------------------------------------------

"let VundleInstalled=1
"let vundle_readme=expand('~/.vim/bundle/vundle/README.md')
"
"if !filereadable(vundle_readme)
"	echo "Installing Vundle.."
"	echo ""
"	silent !mkdir -p ~/.vim/bundle
"	silent !git clone https://github.com/gmarik/vundle ~/.vim/bundle/vundle
"	let VundleInstalled=0
"endif
"
"set rtp+=~/.vim/bundle/vundle/
"call vundle#rc()

" " let Vundle manage Vundle
" Bundle 'gmarik/vundle'

" if has('vim_starting')
"    set nocompatible               " Be iMproved

"    " Required:
"    set runtimepath+=~/.vim/bundle/neobundle.vim/
" endif
" call neobundle#rc(expand('~/.vim/bundle/'))
" BundleFetch 'Shougo/neobundle.vim'

" }}}
" NeoBundle Setup {{{ --------------------------------------------------------

let NeoBundleInstalled=1
let neobundle_readme=expand($HOME.'/.vim/bundle/neobundle.vim/README.md')
if !filereadable(neobundle_readme)
    echo "Installing NeoBundle.."
    echo ""
    silent !mkdir -p $HOME/.vim/bundle
    silent !git clone https://github.com/Shougo/neobundle.vim $HOME/.vim/bundle/neobundle.vim
    let NeoBundleInstalled=0
endif

" Call NeoBundle
if has('vim_starting')
    set rtp+=$HOME/.vim/bundle/neobundle.vim/
endif
call neobundle#begin()

" is better if NeoBundle rules NeoBundle (needed!)
NeoBundle 'Shougo/neobundle.vim'

" }}}
" NeoBundle Bundles {{{ -------------------------------------------------------

" Appearance Utilities {{{
" Vimproc to asynchronously run commands (NeoBundle, Unite)
NeoBundle 'Shougo/vimproc', {
	\ 'build' : {
	\     'windows' : 'make -f make_mingw32.mak',
	\     'cygwin' : 'make -f make_cygwin.mak',
	\     'mac' : 'make -f make_mac.mak',
	\     'unix' : 'make -f make_unix.mak',
	\    },
	\ }
NeoBundle 'Shougo/unite.vim'
"Lightweight status bar with colors and info
"Code tag view and navigation with ctags tags
NeoBundle 'majutsushi/tagbar', {
	\ 'lazy' : 1,
	\ 'autoload' : {
	\     'commands' : ['TagbarToggle']
	\    },
	\ }
"Filesystem explorer
" NeoBundle 'scrooloose/nerdtree.git'
NeoBundle 'Shougo/vimfiler.vim', {
	\ 'lazy' : 1,
	\ 'autoload' : {
	\     'commands' : ['VimFiler']
	\    },
	\ }
"Interactive calculator in vim
NeoBundle 'gregsexton/VimCalc', {
	\ 'lazy' : 1,
	\ 'autoload' : {
	\     'commands' : ['Calc']
	\    },
	\ }

" }}}

" Git Related {{{
"Git management from withing vim
NeoBundle 'tpope/vim-fugitive', {
	\ 'lazy' : 0,
	\ 'autoload' : {
	\     'commands' : ['Fugitive']
	\    },
	\ }
" }}}

"Snippet management
NeoBundle 'SirVer/ultisnips.git'
NeoBundle 'honza/vim-snippets'
"Super tab completion
NeoBundle 'ervandew/supertab.git'
"Easy changing, adding and removing of surround objects
NeoBundle 'tpope/vim-surround', { 'lazy' : 1, 'autoload' : { 'insert' : 1}}
"Closing of brackets, tags, quotes etc.
NeoBundle 'Raimondi/delimitMate', { 'lazy' : 1, 'autoload' : { 'insert' : 1}}
"Syntax checking for a wide range of languages
NeoBundleLazy 'scrooloose/syntastic'
"Easy commenting/uncommenting of code.
NeoBundle 'tpope/vim-commentary'
"Simple alignment of lines
NeoBundle 'tommcdo/vim-lion'
"Multiple useful keybindings
NeoBundle 'tpope/vim-unimpaired'
NeoBundle 'tpope/vim-vinegar'
"Allow incrementing true/false values etc.
NeoBundle 'nishigori/increment-activator'

" Filetype specific {{{
"Override detection of .md files to markdown
NeoBundle 'tpope/vim-markdown', {
	\ 'lazy' : 1,
	\ 'autoload' : {
	\     'filetypes' : ['markdown']
	\    },
	\ }
"Outline files for notes and bits of info.
NeoBundle 'vimoutliner/vimoutliner', {
	\ 'lazy' : 1,
	\ 'autoload' : {
	\     'filetypes' : ['otl', 'votl']
	\    },
	\ }
"Decrypt, edit and then re-encrypt gpg stored files.
NeoBundle 'jamessan/vim-gnupg', {
	\ 'autoload' : {
	\     'filetypes' : ['gpg']
	\    },
	\ }

call neobundle#end()
" }}}

" }}} -------------------------------------------------------------------------

filetype off
let s:has_ag = executable('ag')
let s:has_ack = executable('ack')

" Plugin Settings {{{

"""" UltiSnips Plugin
set runtimepath^=~/.vim/custom
let g:UltiSnipsSnippetsDir        = "~/.vim/custom/mysnippets"
let g:UltiSnipsSnippetDirectories =["UltiSnips","mysnippets"]
let g:UltiSnipsEditSplit          = "vertical"

" let g:UltiSnipsExpandTrigger      ="<tab>"
" let g:UltiSnipsJumpForwardTrigger ="<tab>"
" let g:UltiSnipsJumpBackwardTrigger="<s-tab>"

"""" Syntastic
let g:syntastic_check_on_wq = 0
let g:syntastic_auto_loc_list = 1
let g:syntastic_always_populate_loc_list = 1

"""" Airline Status
" let g:airline#extensions#whitespace#enabled = 0
" let g:airline_right_sep=''
" let g:airline_left_sep =''
" autocmd VimEnter * if index(['markdown'], &ft) < 0 | NeoBundleSource vim-airline
" let g:airline_theme="molokai"

"""" SmartusLine

"""" Molokai Theme
let g:molokai_original = 1

"""" Tagbar
let g:tagbar_sort = 0
let g:tagbar_type_tex = {
	\ 'ctagstype' : 'latex',
	\ 'kinds'     : [
	    \ 's:sections',
	    \ 'g:graphics',
	    \ 'l:labels',
	    \ 'r:refs',
	    \ 'p:pagerefs'
	\ ],
	\ 'sort'    : 0,
\ }

""" Supertab
let g:SuperTabCrMapping = 0 "Needed to allow delimitMate_expand_cr
let g:SuperTabDefaultCompletionType = "context"
let g:SuperTabContextDefaultCompletionType = "<c-n>"

	" better key bindings for UltiSnipsExpandTrigger
	let g:UltiSnipsExpandTrigger = "<tab>"
	let g:UltiSnipsJumpForwardTrigger = "<tab>"
	let g:UltiSnipsJumpBackwardTrigger = "<s-tab>"

"""" delimitMate
let delimitMate_jump_expansion = 0
let delimitMate_expand_cr = 2
let delimitMate_expand_space = 1

""" Unite
if s:has_ag
	let g:unite_source_rec_async_command = 'ag -l .'
	let g:unite_source_grep_command = 'ag'
	let g:unite_source_grep_default_opts = '--smart-case --nogroup --nocolor --line-numbers'
	let g:unite_source_grep_recursive_opt = ''
elseif s:has_ack
	let g:unite_source_rec_async_command = 'ack -f --nofilter'
	let g:unite_source_grep_command = 'ack'
	let g:unite_source_grep_default_opts = '--no-color --no-heading'
	let g:unite_source_grep_recursive_opt = ''
endif

" }}}
" Functions {{{

" View the difference between the buffer and the file the last time it was saved
command! DiffOrig vert new | set bt=nofile | r # | 0d_ | diffthis | wincmd p | diffthis

" }}}
" Settings {{{

filetype plugin on
filetype indent on
syntax on
set ttyfast

" Code Formatting
set autoindent " copy indent from current when starting new line
set copyindent
set encoding=utf-8
set ffs=unix,dos,mac
set formatoptions=tcroqln
silent! set formatoptions+=j
set noeol
set noexpandtab
set preserveindent
set shiftwidth=4
set smartindent
set smarttab
set softtabstop=0
set tabstop=4
set wrap
set textwidth=79

"External Prgs
set path+=../**
if s:has_ag
	set grepprg=ag\ --nogroup\ --nocolor\ --smart-case
else
	set grepprg=grep\ --dereference-recursive\ --ignore-case\ --line-number\ --with-filename\ $*
endif
set keywordprg=""
set makeprg=make
set shell=sh
set complete+=k

"Search
set hlsearch
set ignorecase
set incsearch
set magic
set matchtime=8
set showmatch
set smartcase

"History, Backup and Undo Files
set history=700
set backup
set backupdir=/var/tmp,/tmp
set directory=/var/tmp,/tmp
set writebackup
if exists("&undofile")
	set undofile
	set undodir=~/.vim/undodir
	augroup undo
		autocmd!
		autocmd BufWritePre /tmp/* setlocal noundofile
	augroup END
endif

"Editor Setup
set autoread      " Auto read when a file changes from the outside
set autowrite     " Auto write before make etc.
set linebreak     " Don't break across words
set modeline      " Check for modelines to set files specific settings
set hidden        " Hide buffer when abandoning rather than unloading
set lazyredraw    " Don't redraw the screen for macros and registers
set nostartofline " Dont' move cursor to start of line for gg,G etc.
set matchpairs+=<:>
set listchars=tab:·\ ,trail:▸,nbsp:#
"set lcs=tab:▸\ ,trail:·,eol:¬,nbsp:_
set list

"Editor Styling
set switchbuf=usetab " Method to use when switching buffers
set scrolloff=5      " Number of lines to keep above and below cursor
set synmaxcol=1024   " Syntax highlight long lines

"User Controls
set whichwrap+=<,>,h,l         " Keys that wrap onto next line
set backspace=eol,start,indent " Allow backspacing over

"UI
" colorscheme molokaiJ
colorscheme base16-monokai
set background=dark

set wrapmargin=0 " Wrap text
set showtabline=1
set cursorline
set cmdheight=1
if exists("&relativenumber")
	set relativenumber
endif
set number
set noerrorbells
set novisualbell
set t_vb=
set tm=500
set mouse=a
if $USERNAME == 'jaw097'
	set guifont=DejaVu\ Sans\ Mono\ 10
else
	set guifont=Droid\ Sans\ Mono\ 10
endif
if exists("&colorcolumn")
	set colorcolumn=+1
else
	:mat ErrorMsg '\%81v.\+'
endif
set splitbelow
set splitright

"Command Prompt and status line
set showcmd          " Show last command in last line of scree
set ruler
set laststatus=2     " Show a statusline in all windows
set wildmode=full
set wildmenu
set wildignore=*.o,*~,*.pyc
set wildignore+=*/.git/*,*/.hg/*,*/.svn/*,*.class        "Ignore VCS
if exists("&wildignorecase")
	set wildignorecase
endif

"StatusLine
function! s:insertStatusLine()
	set statusline=
	set statusline+=%1*\ %<%F\                      "full path
	set statusline+=%9*%h                           "help file flag
	set statusline+=%r                              "read only flag
	set statusline+=%w                              "preview flag
	set statusline+=%q                              "quicklist/locationlist flag
	set statusline+=%1*%m%*                         "modified flag
	set statusline+=%=%*                            "left/right separator
	set statusline+=%y                              "filetype
	set statusline+=[%{strlen(&fenc)?&fenc:'none'}, "file encoding
	set statusline+=\ %{&ff}]\                      "file format
	set statusline+=%8*%c,\                         "cursor column
	set statusline+=%l%6*/%L                        "cursor line/total lines
	set statusline+=\ %P                            "percent through file
endfunction
function! s:normalStatusLine()
	set statusline=
	set statusline+=%3*\ %<%F\                      "full path
	set statusline+=%9*%h                           "help file flag
	set statusline+=%r                              "read only flag
	set statusline+=%w                              "preview flag
	set statusline+=%q                              "quicklist/locationlist flag
	set statusline+=%1*%m%*                         "modified flag
	set statusline+=%=%*                            "left/right separator
	set statusline+=%y                              "filetype
	set statusline+=[%{strlen(&fenc)?&fenc:'none'}, "file encoding
	set statusline+=\ %{&ff}]\                      "file format
	set statusline+=%8*%c,\                         "cursor column
	set statusline+=%l%6*/%L                        "cursor line/total lines
	set statusline+=\ %P                            "percent through file
endfunction

call s:normalStatusLine()
au InsertEnter * call s:insertStatusLine()
au InsertLeave * call s:normalStatusLine()

"GUI
if has("gui_running")
	" set guioptions+=P "allow visual selection to be accessed in system paste
	set guioptions+=c "use console dialogues
	set guioptions-=L "left hand toolbar isn't present
	set guioptions-=T "remove tool bar
	set guioptions-=l "remove right scroll
	set guioptions-=m "remove menu bar
	set guioptions-=r "remove left scroll
endif

" automatically open quickfix window after commands that modify the quickfix list
autocmd QuickFixCmdPost *grep* if len(getqflist()) | copen | endif

" go to last cursor position when opening files
autocmd BufReadPost * if line("'\"") > 0 && line("'\"") <= line("$") | exe "normal g'\"" | endif

" }}}
" FileTypes {{{
augroup ft
	autocmd!
	au FileType * exe('setl dict+='.$VIMRUNTIME.'/syntax/'.&filetype.'.vim')
	autocmd BufEnter,BufNew *.tex set ft=tex
	autocmd BufEnter,BufNew *.rout,*.Rout set ft=r
	autocmd Filetype markdown NeoBundleSource vim-markdown
augroup END

augroup vimp
	autocmd!
	autocmd BufEnter *info.gpg set ft=gpg
	autocmd FileType gpg set conceallevel=2
	autocmd FileType gpg :syntax region hideup Conceal start='|' end='$'
	autocmd FileType gpg set colorcolumn=0
augroup END

" }}}
" Keybindings {{{
nnoremap ; :
nnoremap , ;

map <F1> <Nop>

" Try using jk and kj as Escape in insert mode.
inoremap jk <Esc>
inoremap kj <Esc>

" Make j and k move to the next row on screen rather
nmap j gj
nmap k gk
nnoremap n nzz
nnoremap N Nzz

nnoremap Q :normal n.<CR>
nnoremap M %

" Visually select the last inserted text
nmap gV `[v`]

" Delete to black hole with X
noremap X "_d
noremap XX "_dd

" Re-indent whole file
nnoremap g+ :call Preserve("normal gg=G")<CR>

" Insert current filename
inoremap <leader>fn <C-R>=expand("%:t")<CR>

" List all buffers and quickly switch to selected
nmap <leader>b :ls<CR>:buffer<Space>

map <leader>rc :e! ~/.vim/vimrc<CR>
augroup Reload_vimrc
	autocmd!
	autocmd BufWritePost $MYVIMRC source $MYVIMRC | echo "vimrc is sourced"
	autocmd BufWritePost '$HOME/.vim/vimrc' source $MYVIMRC | echo "vimrc is sourced"
	autocmd BufWritePost '~/.vim/vimrc' source $MYVIMRC | echo "vimrc is sourced"
augroup END

" Replace selected text
vnoremap <C-r> "hy:%s/<C-r>h//g<left><left>

" Fast saving
nmap <leader>w :w!<cr>
cabbrev w!! w !sudo tee > /dev/null %
augroup Save
	autocmd!
	au FocusLost * :silent! wa
augroup END

" Save the current file and run the make program
map <F9>   :make<Return>
map <S-F9> :silent make<Return>
map <F10>  :copen<Return>:cprevious<Return>
map <F11>  :copen<Return>:cnext<Return>

" Open the Tagbar sidebar
nnoremap <silent> <F8> :TagbarToggle<CR>

"Toggle NERDTree sidebar
"nmap <F7>   :NERDTreeToggle<CR>
"imap <F7>   :NERDTreeToggle<CR>
"nmap <S-F7> :NERDTreeFind<CR>
"imap <S-F7> :NERDTreeFind<CR>
nmap <F7>   :VimFiler -split -simple -winwidth=30 -toggle -no-quit<CR>
imap <F7>   :VimFiler -split -simple -winwidth=30 -toggle -no-quit<CR>
nmap <S-F7> :VimFiler -split -simple -winwidth=30 -toggle -no-quit -find<CR>
imap <S-F7> :VimFiler -split -simple -winwidth=30 -toggle -no-quit -find<CR>

" Unset highlighting of a search
nmap <leader>q :nohlsearch<CR>

" Switch to Next and Previous buffer
nmap <C-n> :bnext<CR>
nmap <C-p> :bprev<CR>

nmap <leader>v "+gP
imap <leader>v <ESC>"+gpa
nmap <leader>ay ggVG"+y

" Jump to end of pasted text
vnoremap <silent> y y`]
vnoremap <silent> p p`]
nnoremap <silent> p p`]

"           Scroll Wheel = Up/Down 4 lines
"   Shift + Scroll Wheel = Up/Down 1 page
" Control + Scroll Wheel = Up/Down 1/2 page
noremap  <ScrollWheelUp>    6<C-Y>
noremap  <ScrollWheelDown>  6<C-E>
noremap  <S-ScrollWheelUp>   <C-Y>
noremap  <S-ScrollWheelDown> <C-E>
noremap  <C-ScrollWheelUp>   <C-U>
noremap  <C-ScrollWheelDown> <C-D>
inoremap <ScrollWheelUp>     <C-O>4<C-Y>
inoremap <ScrollWheelDown>   <C-O>4<C-E>
inoremap <S-ScrollWheelUp>   <C-O><C-Y>
inoremap <S-ScrollWheelDown> <C-O><C-E>
inoremap <C-ScrollWheelUp>   <C-O><C-U>
inoremap <C-ScrollWheelDown> <C-O><C-D>
map      <MiddleMouse>       <LeftMouse>
imap     <MiddleMouse>       <LeftMouse>
map      <2-MiddleMouse>     <LeftMouse>
imap     <2-MiddleMouse>     <LeftMouse>
map      <3-MiddleMouse>     <LeftMouse>
imap     <3-MiddleMouse>     <LeftMouse>
map      <4-MiddleMouse>     <LeftMouse>
imap     <4-MiddleMouse>     <LeftMouse>

" }}}

" vim: fdm=marker
